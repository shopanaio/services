# ansible-playbook install-woodpecker-config-service.yml
---
- name: Install config-service on remote host
  hosts: shopana
  become: true
  gather_facts: true

  vars:
    app_name: config-service
    app_dir: /opt/config-service
    app_data_dir: /opt/config-service/data
    image: config-service:local
    container_port: 3000
    host_http_port: 3300
    local_build_dir: "{{ playbook_dir }}/../.."
    image_tar_name: "{{ app_name }}.tar"
    local_image_path: "/tmp/{{ image_tar_name }}"
    remote_image_path: "{{ app_dir }}/{{ image_tar_name }}"

    # Values must be provided via extra vars or env/vault (no defaults)
    WOODPECKER_GITHUB_TOKEN: "{{ lookup('env', 'WOODPECKER_GITHUB_TOKEN') }}"
    WOODPECKER_CONFIG_SERVICE_SECRET: "{{ lookup('env', 'WOODPECKER_CONFIG_SERVICE_SECRET') }}"

  tasks:
    - name: Validate required variables are provided
      ansible.builtin.assert:
        that:
          - WOODPECKER_GITHUB_TOKEN is defined and WOODPECKER_GITHUB_TOKEN | length > 0
          - WOODPECKER_CONFIG_SERVICE_SECRET is defined and WOODPECKER_CONFIG_SERVICE_SECRET | length > 0
        fail_msg: >-
          Required variables missing. Provide WOODPECKER_GITHUB_TOKEN, WOODPECKER_CONFIG_SERVICE_SECRET
          via environment or -e "VAR=...".
        success_msg: "All required variables are present"

    - name: Installation block with error handling
      block:
        - name: Build Docker image locally for linux/amd64
          ansible.builtin.command:
            cmd: docker build --platform linux/amd64 -t {{ image }} -f ci/config-service/Dockerfile .
            chdir: "{{ local_build_dir }}"
          delegate_to: localhost
          become: false
          changed_when: true

        - name: Save Docker image to tar file locally
          ansible.builtin.command:
            cmd: docker save -o {{ local_image_path }} {{ image }}
          delegate_to: localhost
          become: false
          changed_when: true

        - name: Ensure application directories exist on remote host
          ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            mode: '0755'
          loop:
            - "{{ app_dir }}"
            - "{{ app_data_dir }}"

        - name: Copy Docker image tar to remote host
          ansible.builtin.copy:
            src: "{{ local_image_path }}"
            dest: "{{ remote_image_path }}"
            mode: '0644'

        - name: Load Docker image on remote host
          ansible.builtin.command:
            cmd: docker load -i {{ remote_image_path }}
          changed_when: true

        - name: Remove image tar file from remote host
          ansible.builtin.file:
            path: "{{ remote_image_path }}"
            state: absent

        - name: Remove local image tar file
          ansible.builtin.file:
            path: "{{ local_image_path }}"
            state: absent
          delegate_to: localhost
          become: false

        - name: Create docker-compose.yml for {{ app_name }}
          ansible.builtin.copy:
            dest: "{{ app_dir }}/docker-compose.yml"
            mode: '0644'
            content: |
              services:
                {{ app_name }}:
                  image: {{ image }}
                  container_name: {{ app_name }}
                  restart: unless-stopped
                  ports:
                    - "0.0.0.0:{{ host_http_port }}:{{ container_port }}"
                  environment:
                    - PORT={{ container_port }}
                    - LOG_LEVEL=debug
                    - NODE_ENV=production
                    - WOODPECKER_GITHUB_TOKEN=${WOODPECKER_GITHUB_TOKEN}
                    - WOODPECKER_CONFIG_SERVICE_SECRET=${WOODPECKER_CONFIG_SERVICE_SECRET}
                    # Temporarily skip signature verification until Woodpecker public key is configured
                    - SKIP_SIGNATURE_VERIFICATION=true
                    # Only GitHub is supported

        - name: Create .env for {{ app_name }}
          ansible.builtin.copy:
            dest: "{{ app_dir }}/.env"
            mode: '0600'
            content: |
              # {{ app_name }} configuration
              WOODPECKER_GITHUB_TOKEN={{ WOODPECKER_GITHUB_TOKEN }}
              WOODPECKER_CONFIG_SERVICE_SECRET={{ WOODPECKER_CONFIG_SERVICE_SECRET }}
              # Only GitHub is supported

        - name: Cleanup containers on port {{ host_http_port }}
          ansible.builtin.include_tasks: cleanup-port-task.yml
          vars:
            cleanup_port: "{{ host_http_port }}"

        - name: Stop and remove existing {{ app_name }} container if running
          ansible.builtin.command:
            cmd: docker compose down
            chdir: "{{ app_dir }}"
          ignore_errors: true
          changed_when: true

        - name: Wait for port to be released
          ansible.builtin.wait_for:
            port: "{{ host_http_port }}"
            state: stopped
            timeout: 30
          ignore_errors: true

        - name: Additional pause to ensure cleanup
          ansible.builtin.pause:
            seconds: 2

        - name: Start {{ app_name }}
          ansible.builtin.command:
            cmd: docker compose up -d
            chdir: "{{ app_dir }}"
          changed_when: true

        - name: Wait a moment for container to start
          ansible.builtin.pause:
            seconds: 3

        - name: Show startup logs
          ansible.builtin.command:
            cmd: docker compose logs --tail=30
            chdir: "{{ app_dir }}"
          register: startup_logs
          changed_when: false

        - name: Display startup logs
          ansible.builtin.debug:
            var: startup_logs.stdout_lines

        - name: Wait for {{ app_name }} to listen on {{ host_http_port }}
          ansible.builtin.wait_for:
            host: 127.0.0.1
            port: "{{ host_http_port }}"
            delay: 2
            timeout: 60
          ignore_errors: true

        - name: Show container status
          ansible.builtin.command:
            cmd: docker compose ps
            chdir: "{{ app_dir }}"
          register: compose_ps
          changed_when: false

        - name: Display status
          ansible.builtin.debug:
            var: compose_ps.stdout_lines

        - name: Show access info
          ansible.builtin.debug:
            msg:
              - "‚úÖ {{ app_name }} deployed"
              - ""
              - "üåê Service Info:"
              - "  HTTP: http://{{ ansible_host }}:{{ host_http_port }}"
              - "  Health: http://{{ ansible_host }}:{{ host_http_port }}/healthz"
              - "  Dir: {{ app_dir }}"
              - "  Env: {{ app_dir }}/.env"
              - ""
              - "üìä View Logs:"
              - "  ansible-playbook logs-config-service.yml"
              - "  ansible-playbook logs-config-service.yml -e 'follow=true'"
              - "  ansible-playbook manage-config-service.yml -e 'action=logs'"
              - ""
              - "üîß Manage Service:"
              - "  ansible-playbook manage-config-service.yml -e 'action=restart'"
              - "  ansible-playbook manage-config-service.yml -e 'action=status'"
              - ""
              - "üßπ Cleanup Port:"
              - "  ansible-playbook cleanup-port.yml -e 'cleanup_port={{ host_http_port }}'"

      rescue:
        - name: Show error details
          ansible.builtin.debug:
            msg:
              - "‚ùå Installation failed!"
              - "Error: {{ ansible_failed_result.msg | default('Unknown error') }}"
              - ""
              - "Attempting to show current state..."

        - name: Show container status on error
          ansible.builtin.command:
            cmd: docker compose ps
            chdir: "{{ app_dir }}"
          register: error_compose_ps
          changed_when: false
          ignore_errors: true

        - name: Display error container status
          ansible.builtin.debug:
            var: error_compose_ps.stdout_lines
          when: error_compose_ps is defined

        - name: Show container logs on error
          ansible.builtin.command:
            cmd: docker compose logs --tail=50
            chdir: "{{ app_dir }}"
          register: error_logs
          changed_when: false
          ignore_errors: true

        - name: Display error logs
          ansible.builtin.debug:
            var: error_logs.stdout_lines
          when: error_logs is defined and error_logs.stdout_lines is defined

        - name: Show recovery instructions
          ansible.builtin.debug:
            msg:
              - "To retry installation:"
              - "  ansible-playbook install-config-service.yml"
              - ""
              - "If port {{ host_http_port }} is occupied:"
              - "  ansible-playbook cleanup-port.yml -e 'cleanup_port={{ host_http_port }}'"
              - ""
              - "To check logs manually:"
              - "  ssh {{ ansible_host }} 'cd {{ app_dir }} && docker compose logs'"
              - ""
              - "To clean up and start fresh:"
              - "  ssh {{ ansible_host }} 'cd {{ app_dir }} && docker compose down && rm -rf {{ app_dir }}'"

        - name: Fail with message
          ansible.builtin.fail:
            msg: "Installation failed. See error details above."
